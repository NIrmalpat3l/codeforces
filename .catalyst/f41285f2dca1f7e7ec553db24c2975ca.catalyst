{"title":{"en":"G1. Subsequence Addition (Easy Version)","ru":"G1. Последовательное сложение (простая версия)"},"contestId":"1807","problemIndex":"G1","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"256 megabytes","ru":"256 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p><span class=\"tex-font-style-it\">The only difference between the two versions is that in this version, the constraints are lower.</span></p><p>Initially, array $$$a$$$ contains just the number $$$1$$$. You can perform several operations in order to change the array. In an operation, you can select some subsequence$$$^{\\dagger}$$$ of $$$a$$$ and add into $$$a$$$ an element equal to the sum of all elements of the subsequence. </p><p>You are given a final array $$$c$$$. Check if $$$c$$$ can be obtained from the initial array $$$a$$$ by performing some number (possibly 0) of operations on the initial array.</p><p>$$$^{\\dagger}$$$ A sequence $$$b$$$ is a subsequence of a sequence $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by the deletion of several (possibly zero, but not all) elements. In other words, select $$$k$$$ ($$$1 \\leq k \\leq |a|$$$) distinct indices $$$i_1, i_2, \\dots, i_k$$$ and insert anywhere into $$$a$$$ a new element with the value equal to $$$a_{i_1} + a_{i_2} + \\dots + a_{i_k}$$$.</p>","ru":"<p><span class=\"tex-font-style-it\">Единственное различие между двумя версиями в том, что в этой версии ограничения ниже.</span></p><p>Изначально массив $$$a$$$ содержит только число $$$1$$$. Вы можете выполнить несколько операций, чтобы изменить массив. За одну операцию можно выбрать некоторую подпоследовательность $$$^{\\dagger}$$$ из $$$a$$$ и вставить на любую позицию в $$$a$$$ элемент, равный сумме всех элементов подпоследовательности.</p><p>Вам дан массив $$$c$$$. Проверьте, можно ли получить из массива $$$a$$$ массив $$$c$$$, выполнив некоторое количество (возможно, 0) операций над исходным массивом.</p><p>$$$^{\\dagger}$$$ Последовательность $$$b$$$ является подпоследовательностью последовательности $$$a$$$, если $$$b$$$ может быть получена из $$$a$$$ удалением нескольких (возможно, нуля, но не всех) элементов. Другими словами, операция выглядит так: выберем $$$k$$$ ($$$1 \\leq k \\leq |a|$$$) различных индексов $$$i_1, i_2, \\dots, i_k$$$ и вставим в любое место $$$a$$$ новый элемент со значением, равным $$$a_{i_1} + a_{i_2} + \\dots + a_{i_k}$$$.</p>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The first line of the input contains an integer $$$t$$$ ($$$1 \\leq t \\leq 1000$$$)&nbsp;— the number of test cases. The description of the test cases follows.</p><p>The first line of each test case contains a single integer $$$n$$$ ($$$1 \\leq n \\leq 5000$$$) &nbsp;— the number of elements the final array $$$c$$$ should have.</p><p>The second line of each test case contains $$$n$$$ space-separated integers $$$c_i$$$ ($$$1 \\leq c_i \\leq 5000$$$) &nbsp;— the elements of the final array $$$c$$$ that should be obtained from the initial array $$$a$$$.</p><p>It is guaranteed that the sum of $$$n$$$ over all test cases does not exceed $$$5000$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>Первая строка входных данных содержит целое число $$$t$$$ ($$$1 \\leq t \\leq 1000$$$)&nbsp;— количество наборов входных данных. Далее следует описание наборов входных данных.</p><p>Первая строка каждого набора входных данных содержит одно целое число $$$n$$$ ($$$1 \\leq n \\leq 5000$$$)&nbsp;— длину массива $$$c$$$.</p><p>Вторая строка каждого набора входных данных содержит $$$n$$$ разделенных пробелами целых чисел $$$c_i$$$ ($$$1 \\leq c_i \\leq 5000$$$)&nbsp;— массив $$$c$$$, который вам нужно получить из массива $$$a$$$.</p><p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных не превышает $$$5000$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>For each test case, output \"<span class=\"tex-font-style-tt\">YES</span>\" (without quotes) if such a sequence of operations exists, and \"<span class=\"tex-font-style-tt\">NO</span>\" (without quotes) otherwise.</p><p>You can output the answer in any case (for example, the strings \"<span class=\"tex-font-style-tt\">yEs</span>\", \"<span class=\"tex-font-style-tt\">yes</span>\", \"<span class=\"tex-font-style-tt\">Yes</span>\" and \"<span class=\"tex-font-style-tt\">YES</span>\" will be recognized as a positive answer).</p>","ru":"<div class=\"section-title\">Выходные данные</div><p>Для каждого набора входных данных выведите «<span class=\"tex-font-style-tt\">YES</span>» (без кавычек), если такая последовательность операций существует, и «<span class=\"tex-font-style-tt\">NO</span>» (без кавычек) в противном случае.</p><p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную). Например, строки «<span class=\"tex-font-style-tt\">yEs</span>», «<span class=\"tex-font-style-tt\">yes</span>», «<span class=\"tex-font-style-tt\">Yes</span>» и «<span class=\"tex-font-style-tt\">YES</span>» будут приняты как положительный ответ.</p>"},"noteHtml":{"en":"<div class=\"section-title\">Note</div><p>For the first test case, the initial array $$$a$$$ is already equal to $$$[1]$$$, so the answer is \"<span class=\"tex-font-style-tt\">YES</span>\".</p><p>For the second test case, performing any amount of operations will change $$$a$$$ to an array of size at least two which doesn't only have the element $$$2$$$, thus obtaining the array $$$[2]$$$ is impossible and the answer is \"<span class=\"tex-font-style-tt\">NO</span>\".</p><p>For the third test case, we can perform the following operations in order to obtain the final given array $$$c$$$:</p><ul><li> Initially, $$$a = [1]$$$. </li><li> By choosing the subsequence $$$[1]$$$, and inserting $$$1$$$ in the array, $$$a$$$ changes to $$$[1, 1]$$$. </li><li> By choosing the subsequence $$$[1, 1]$$$, and inserting $$$1+1=2$$$ in the middle of the array, $$$a$$$ changes to $$$[1, 2, 1]$$$.</li><li> By choosing the subsequence $$$[1, 2]$$$, and inserting $$$1+2=3$$$ after the first $$$1$$$ of the array, $$$a$$$ changes to $$$[1, 3, 2, 1]$$$.</li><li> By choosing the subsequence $$$[1, 3, 1]$$$ and inserting $$$1+3+1=5$$$ at the beginning of the array, $$$a$$$ changes to $$$[5, 1, 3, 2, 1]$$$ (which is the array we needed to obtain).</li></ul>","ru":"<div class=\"section-title\">Примечание</div><p>Для первого набора входных данных исходный массив $$$a$$$ уже равен $$$[1]$$$, поэтому ответ «<span class=\"tex-font-style-tt\">YES</span>».</p><p>Для второго набора входных данных после выполнения любого количества операций длина массива $$$a$$$ станет хотя бы два, а в начальном массиве элемента $$$2$$$ нет, поэтому получить массив $$$[2]$$$ невозможно, и ответ будет «<span class=\"tex-font-style-tt\">NO</span>».</p><p>Для третьего набора входных данных мы можем выполнить следующие операции, чтобы получить массив $$$c$$$:</p><ul><li> Первоначально, $$$a = [1]$$$.</li><li> Выбрав подпоследовательность $$$[1]$$$ и вставив $$$1$$$ в массив, $$$a$$$ станет равным $$$[1, 1]$$$.</li><li> Выбрав подпоследовательность $$$[1, 1]$$$ и вставив $$$1+1=2$$$ в середину массива, $$$a$$$ станет равным $$$[1, 2, 1]$$$.</li><li> Выбрав подпоследовательность $$$[1, 2]$$$ и вставив $$$1+2=3$$$ после первой $$$1$$$ массива, $$$a$$$ станет равным $$$[1, 3, 2, 1]$$$.</li><li> Выбрав подпоследовательность $$$[1, 3, 1]$$$ и вставив $$$1+3+1=5$$$ в начало массива, $$$a$$$ станет равным $$$[5, 1, 3, 2, 1]$$$ (именно такой массив нам нужно было получить).</li></ul>"},"sampleTestcases":[{"id":1679245099070,"input":"6\n1\n1\n1\n2\n5\n5 1 3 2 1\n5\n7 1 5 2 1\n3\n1 1 1\n5\n1 1 4 2 1","output":"YES\nNO\nYES\nNO\nYES\nYES\n","result":{"id":1679245099070,"stdout":"YES\r\nNO\r\nYES\r\nNO\r\nYES\r\nYES\r\n","stderr":"","exitcode":0,"signal":null,"time":698,"timeout":false}}],"submitUrl":"https://codeforces.com/contest/1807/submit","language":"c++"}